## OpenKPIs Upgrade Plan – Server-Rendered, Production-Ready App

This document tracks the upgrade tasks needed to make the app production-ready while **reducing** complexity and avoiding fragile client-only behavior.

---

### 1. Data Delivery and Rendering

- **1.1 Convert KPI list to server-rendered page**
  - Refactor `app/(content)/kpis/page.tsx` into:
    - A **server component** that fetches data using Supabase server helpers.
    - A small **client component** for filters/search that receives `initialItems` and `initialUser` as props.
  - Use the Supabase **admin client** (service-role key) or well-defined RLS policies to fetch:
    - All KPIs where `status ilike 'published'`.
    - Plus any KPIs where `created_by` matches the current user (GitHub username and/or email).
  - Ensure the HTML sent by Vercel already contains the KPI cards (no initial "Loading…" text).

- **1.2 Apply the same SSR pattern to all catalog pages**
  - Pages: `dimensions`, `metrics`, `events`, `dashboards`.
  - For each:
    - Fetch data on the server with the same published-or-mine logic.
    - Pass the rows into a dedicated client component (or re-use a generic one) that handles filters and search.

- **1.3 Centralize list fetching logic on the server**
  - Create a reusable helper (e.g., `lib/lists/fetchEntitiesServer.ts`) that:
    - Accepts `kind`, `includeMine`, optional filters.
    - Uses admin client or RLS-approved client to fetch and sort entities.
  - Ensure all list pages rely on this helper for initial render (no `fetch('/api/debug/list')` on first paint).
  - Respect the new `NEXT_PUBLIC_APP_ENV` variable to choose the proper table prefix (`dev_` vs `prod_`) so a single Supabase project can host both datasets.

- **1.4 Server-driven refresh after auth changes**
  - When a user signs in/out, invoke the same server helper (via a server action or server route) to rebuild the list and re-render the component.
  - Avoid client-only fetches; let the server send back the updated data to keep client and server views identical.

---

### 2. Authentication and Session Handling

- **2.1 Centralize login around the Supabase GitHub session**
  - Treat the Supabase OAuth flow as the single source of truth.
  - Remove duplicate GitHub sign-in prompts across AI Analyst, Editor, My Profile, Giscus, etc.; they should all read the same Supabase session.
  - If a feature needs extra scopes, reuse the stored GitHub token returned by Supabase rather than re-triggering OAuth.

- **2.2 Harden the `/auth/callback` flow**
  - Keep it purely server-side:
    - Exchange the GitHub `code` with `createClient()`.
    - Set cookies and redirect immediately to `openkpis_return_url`.
  - No client polling or “please wait” UI.

- **2.3 Hydrate `AuthProvider` from server data**
  - When a page renders, embed the user (and role) discovered on the server and hand it to `AuthProvider`.
  - Only fall back to `supabase.auth.getSession()` after hydration if something changes (e.g., token refresh).

- **2.4 Use server session for user-aware pages**
  - On `/myprofile`, new-item pages, editor tools, etc., fetch the session on the server and pass the user via props. Avoid client waits for `getCurrentUser()`.

- **2.5 Prune custom auth events / listeners**
  - Review uses of `openkpis-auth-change` and `openkpis-sign-out`.
  - Keep only the minimal hooks needed for real-time UI adjustments; remove fetch duplication now that SSR supplies initial data.

- **2.6 Align third-party integrations**
  - Configure Giscus, AI Analyst tooling, and any editor workflow to consume the centralized Supabase session (and shared GitHub token) instead of independent auth flows.

---

### 3. UI, UX, and CSS Consistency

- **3.1 Standardize catalog layout**
  - Confirm `Catalog` renders:
    - Title + description on the left.
    - "Add New \<Entity\>" button on the right.
    - Search and filters below in a unified layout.
  - Ensure all list pages (KPIs, Dimensions, Metrics, Events, Dashboards) use this same visual pattern and spacing.

- **3.2 Move repeated inline styles into CSS**
  - Identify common patterns (cards, buttons, filter controls) and extract them into CSS classes under `app/styles/*.css`.
  - Keep component-specific tweaks small and inline, but avoid large style blocks repeated across files.

- **3.3 Normalize call-to-action button styling**
  - Audit button styles (especially “Add New …” CTAs) to ensure hover/active states keep adequate contrast.
  - Prevent white-on-white combinations by defining a shared CSS class with a consistent hover palette.
  - Verify the theme works across light/dark backgrounds and maintains accessibility contrast ratios.

- **3.4 Remove loading indicators once SSR is in place**
  - Eliminate "Loading…" text and similar client-only placeholders from list pages.
  - For true empty states, render:
    - A clear "No items found. Try adjusting your filters." message.
    - If appropriate, a call to action like "Create the first KPI".

- **3.5 Check mobile and keyboard UX**
  - Verify that navigation, filters, and dropdowns are keyboard-accessible.
  - Confirm responsive behavior of cards and filters on common breakpoints.

---

### 4. API and Debug Endpoints

- **4.1 Restrict `/api/debug/*` in production**
  - Keep existing debug routes (`/api/debug/auth`, `/api/debug/env`, `/api/debug/list`, `/api/debug/version`) for troubleshooting, but:
    - Add guards so they only respond when:
      - `NODE_ENV !== 'production'`, or
      - A secret debug token / header is present.
  - Avoid exposing service-role powered endpoints to anonymous internet traffic long term.

- **4.1a Publish a private debug sitemap**
  - Maintain a simple markdown or JSON “debug sitemap” listing available diagnostic endpoints.
  - Do not expose it publicly; only authenticated admins (or anyone with the secret token) can view/use it.
  - Ensure each endpoint checks auth/secret and logs access for auditing.

- **4.2 Remove `/api/debug/list` from main UI flow**
  - Replace any client-side use of `/api/debug/list` in pages with SSR data fetching.
  - Leave the route only for diagnostics and internal verification.

- **4.3 Document debugging steps**
  - Create a short guide under `internal-files/` that explains how to:
    - Capture HAR files.
    - Call debug API endpoints (when enabled).
    - Interpret "published vs mine" behavior.

---

### 5. Supabase RLS and Admin Client Strategy

- **5.1 Finalize access model for enterprise readiness**
  - Adopt a hybrid approach:
    - Keep RLS policies for published content so anonymous traffic can read `status ilike 'published'` rows securely.
    - Use the admin client only inside server-rendered pages or trusted API routes when we need drafts or privileged data.
  - Ensure every server helper respects the `NEXT_PUBLIC_APP_ENV` prefix (DEV/PROD) and applies the correct table names and policies.
- **5.2 Offload OpenAI/AI Analyst calls to the server**
  - Move AI Analyst’s OpenAI requests into server actions or API routes so the OpenAI key is never exposed to the client.
  - Add rate limiting, logging, and Supabase session checks server-side before invoking OpenAI.
  - The browser should submit prompts to the server endpoint and render whatever response the server returns.

- **5.3 Table migration discipline**
  - During development, work against the `dev_` prefixed tables.
  - For Production, maintain a changelog of schema and RLS updates (create/alter/delete statements).
  - When promoting to production, rerun those statements against the `prod_` prefixed tables and verify policies mirror the dev setup.
  - Document the process so Prod can be kept in sync manually or via migration scripts when Supabase project limits change.

- **5.2 Implement and verify RLS policies for public content**
  - For `kpis` (and any other public entities), ensure policies include:
    - `grant usage on schema public to anon, authenticated;`
    - `grant select on public.kpis to anon, authenticated;`
    - `alter table public.kpis enable row level security;`
    - `create policy "public_read_published_kpis" on public.kpis for select to anon, authenticated using (status ilike 'published');`
  - Repeat analogous policies for `metrics`, `dimensions`, `events`, and `dashboards` if they are also intended to be publicly browsable.

- **5.3 Use admin client only where justified**
  - Limit `createAdminClient()` usage to:
    - Server-rendered pages.
    - Internal API routes where service-role access is required.
  - Never expose admin-driven responses directly to unvalidated client input (e.g., arbitrary filters from query strings) without proper validation.

---

### 6. Deployment, Testing, and Verification

- **6.1 Local verification before any push**
  - Run through full flows on `http://localhost:3000`:
    - Anonymous visit to `/kpis` and all catalog pages.
    - GitHub login, then navigate to `/kpis` and confirm published + own drafts appear.
    - My Profile, new-item pages, and editor flows.
  - Capture local HARs for `/kpis` before and after login to confirm:
    - HTML includes KPI cards from SSR.
    - There is no dependency on client-only fetches for the initial view.

- **6.2 Vercel preview deployment**
  - After local validation, push to a feature branch and let Vercel create a preview deployment.
  - Repeat the HAR capture and auth-flow verification on the preview URL.
  - Confirm that:
    - Supabase RLS policies (or admin client) behave the same as locally.
    - The page no longer gets stuck on "Loading…" or on a zero-KPI state.

- **6.3 Promote to production**
  - Once preview is stable, merge to `main` and allow Vercel to deploy to `dev.openkpis.org`.
  - Perform a final smoke test:
    - Anonymous and logged-in `/kpis`.
    - Other catalog pages.
    - Sign-in / sign-out and `/myprofile`.
  - Only then call the upgrade complete.

---

### 7. Longer-Term Considerations (Optional)

- **7.1 Edge caching or Cloudflare integration**
  - After correctness and SSR are solid, evaluate whether to:
    - Add edge caching (Vercel cache or Cloudflare) for published lists.
    - Move specific endpoints to Cloudflare Workers for lower latency.
  - This should be treated as an optimization phase, not part of the stability upgrade.

- **7.2 Evaluate Supabase vs AWS for future growth**
  - Once stability is achieved, revisit whether Supabase continues to match requirements for:
    - Data residency and compliance.
    - Scaling and performance.
    - Access control and IAM complexity.
  - If not, outline a separate migration plan (outside the scope of this immediate upgrade) to AWS or another backend.


